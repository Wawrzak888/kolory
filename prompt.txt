Studium Wykonalności Technicznej i Strategia Wdrożenia Aplikacji PWA „Łowcy Kolorów”: Rzeczywistość Rozszerzona w Edukacji PrzedszkolnejStreszczenie ZarządczeNiniejszy raport stanowi kompleksową analizę techniczną, psychologiczną i logistyczną projektu „Łowcy Kolorów” (Color Hunters) – edukacyjnej aplikacji typu Progressive Web App (PWA) wykorzystującej Rzeczywistość Rozszerzoną (AR). Głównym celem opracowania jest weryfikacja hipotezy, czy możliwe jest stworzenie aplikacji webowej, która działa „bezbłędnie” na urządzeniach mobilnych (tabletach i telefonach z systemami Android oraz iOS), oferując płynność i stabilność porównywalną z aplikacjami natywnymi, przy jednoczesnym zachowaniu niskiej bariery wejścia charakterystycznej dla rozwiązań webowych.Analiza przeprowadzona w oparciu o najnowsze standardy webowe (stan na rok 2025/2026) potwierdza, że projekt jest technicznie wykonalny, jednak osiągnięcie poziomu „bezbłędnego działania” (flawless performance) wymaga zastosowania zaawansowanych strategii optymalizacyjnych oraz specyficznych obejść (workarounds) dla ograniczeń silnika WebKit na urządzeniach firmy Apple. Kluczowym wnioskiem jest konieczność przyjęcia architektury „Privacy-First” opartej na przetwarzaniu lokalnym (Edge AI/Client-side Processing), co eliminuje opóźnienia sieciowe i rozwiązuje kwestie prawne związane z przetwarzaniem wizerunku dzieci.W raporcie szczegółowo omówiono przewagę modelu barw HSL nad RGB w kontekście algorytmów detekcji kolorów w zmiennych warunkach oświetleniowych, strategie zarządzania cyklem życia aplikacji PWA w celu uniknięcia błędów „czarnego ekranu” kamery, a także hybrydowe podejście do syntezy mowy w języku polskim, łączące Web Speech API z plikami audio jako zabezpieczeniem (fallback). Dokument ten służy jako techniczna mapa drogowa (roadmap) dla zespołu deweloperskiego, definiując standardy kodowania, stos technologiczny oraz protokoły testowe niezbędne do sukcesu rynkowego aplikacji.1. Wstęp: Konwergencja Technologii Webowych i Edukacji WczesnoszkolnejEwolucja technologii edukacyjnych (EdTech) zmierza nieuchronnie w kierunku interfejsów immersyjnych, które wyprowadzają interakcję poza ekran urządzenia, angażując motorykę dużą dziecka i jego orientację w przestrzeni fizycznej. Aplikacja „Łowcy Kolorów” wpisuje się w nurt tzw. „Active AR” (Aktywnej Rzeczywistości Rozszerzonej), gdzie tablet lub telefon nie jest pasywnym wyświetlaczem treści, lecz narzędziem badawczym – „magiczną różdżką” lub „soczewką”, przez którą dziecko analizuje otaczający je świat.1.1 Uzasadnienie Wyboru Technologii PWATradycyjne podejście do tworzenia tego typu rozwiązań zakładało budowę dwóch niezależnych aplikacji natywnych (Swift dla iOS, Kotlin/Java dla Androida). Jednakże w kontekście grupy docelowej (rodzice dzieci w wieku 4-6 lat) oraz specyfiki dystrybucji treści edukacyjnych, technologia Progressive Web App oferuje strategiczne przewagi, które mogą zadecydować o sukcesie projektu:CechaAplikacja NatywnaPWA (Łowcy Kolorów)Implikacja dla ProjektuDystrybucjaSklep z aplikacjami (wymaga hasła, instalacji)Link (URL), kod QRNatychmiastowy dostęp, kluczowy przy impulsywnym zainteresowaniu dziecka.AktualizacjeProces recenzji (24-48h), pobieranieNatychmiastowe (po odświeżeniu)Możliwość szybkiego łatania błędów krytycznych bez ingerencji użytkownika.WspółdzielenieTrudne (różne systemy)Uniwersalne (każde urządzenie z przeglądarką)Działa na starym tablecie z Androidem i nowym iPadzie bez zmian w kodzie.Koszt DevWysoki (dwa zespoły)Średni (jeden kod)Budżet można przekierować na dopracowanie UX i algorytmów AI.Wybór PWA nakłada jednak na zespół deweloperski rygorystyczne wymagania optymalizacyjne. Przeglądarka internetowa jest dodatkową warstwą abstrakcji między kodem a sprzętem (kamerą, GPU), co w przeszłości generowało opóźnienia nieakceptowalne w grach. Obecnie, dzięki standardom takim jak WebAssembly, WebGL oraz zoptymalizowanym silnikom JavaScript (V8, JavaScriptCore), bariera ta została zminimalizowana, pod warunkiem zastosowania odpowiednich technik programistycznych.11.2 Definicja „Bezbłędnego Działania”W kontekście zapytania użytkownika, termin „działać bezbłędnie” należy zdefiniować poprzez mierzalne parametry techniczne (KPI), które będą wyznacznikiem sukcesu wdrożenia:Płynność wizualna: Interfejs kamery musi utrzymywać stabilne 30-60 klatek na sekundę (FPS). Spadki poniżej 24 FPS będą odczuwane jako „zacinanie się”, co u dzieci w wieku przedszkolnym prowadzi do natychmiastowej utraty zainteresowania.2Responsywność detekcji: Czas od momentu, gdy dziecko skieruje kamerę na czerwony przedmiot, do momentu reakcji aplikacji (dźwięk/animacja), nie może przekraczać 200-300 milisekund.Stabilność sesji: Aplikacja nie może tracić dostępu do kamery po zablokowaniu ekranu lub odebraniu połączenia telefonicznego (krytyczne na iOS).3Odporność na warunki środowiskowe: Algorytm musi poprawnie identyfikować kolory zarówno w świetle dziennym, jak i przy sztucznym oświetleniu wieczornym (problem temperatury barwowej).42. Architektura Systemu i Stos Technologiczny (Stack 2025)Aby sprostać powyższym wymaganiom, rekomenduje się architekturę opartą na Single Page Application (SPA) z silnym naciskiem na przetwarzanie lokalne.2.1 Architektura „Privacy-First” i „Offline-First”Bezpieczeństwo danych dzieci jest priorytetem. W proponowanym modelu żadna klatka obrazu z kamery nie jest wysyłana na serwer. Cała analiza odbywa się w pamięci RAM urządzenia użytkownika (Client-side). Jest to podejście zgodne z RODO (GDPR) oraz ustawą COPPA, co stanowi silny argument marketingowy dla rodziców.Dodatkowo, zastosowanie Service Workers pozwala na pełne działanie offline. Po pierwszym załadowaniu, aplikacja, jej zasoby graficzne, dźwiękowe oraz modele AI (jeśli są używane) zostają zapisane w pamięci podręcznej przeglądarki (Cache Storage API oraz IndexedDB). Dzięki temu „Łowcy Kolorów” zadziałają nawet w trybie samolotowym lub w miejscach bez zasięgu, co jest typowym scenariuszem użytkowania tabletów przez dzieci (np. w podróży).62.2 Framework i BibliotekiZalecany stos technologiczny minimalizuje narzut obliczeniowy (overhead), pozostawiając maksymalną moc obliczeniową dla analizy obrazu:Jądro Aplikacji: Czysty JavaScript (ES6+) lub Svelte. Należy unikać ciężkich frameworków jak Angular czy React w ich domyślnych konfiguracjach, ponieważ wirtualny DOM może wprowadzać mikro-opóźnienia przy renderowaniu 60 FPS w pętli gry. Svelte, kompilujący się do czystego JS, jest idealnym kompromisem między ergonomią deweloperską a wydajnością.2UI/Styling: TailwindCSS. Umożliwia szybkie tworzenie responsywnych interfejsów, które skalują się od małych iPhone'ów SE do dużych iPadów Pro, z wbudowaną obsługą trybów jasnych/ciemnych oraz bezpiecznych stref ekranu (Safe Areas).1Silnik AI/Wizyjny:Opcja A (Detekcja Obiektów): TensorFlow.js z modelem COCO-SSD (wersja lite_mobilenet_v2). Pozwala na rozpoznawanie konkretnych kształtów (np. „znajdź kubek”, „znajdź piłkę”). Jest to rozwiązanie cięższe (wymaga załadowania modelu ~2-5MB), ale bardziej „inteligentne”.9Opcja B (Czysta Detekcja Kolorów): Algorytm oparty na HTML5 Canvas API i matematyce przestrzeni barw HSL. Jest to rozwiązanie natychmiastowe (brak czasu ładowania modelu), ultra-lekkie i wystarczające do mechaniki „znajdź coś czerwonego”.Rekomendacja: Hybryda. Domyślnie używamy Opcji B dla responsywności, a Opcję A ładujemy w tle dla zaawansowanych poziomów („Znajdź czerwoną piłkę”).Zarządzanie Stanem PWA: Biblioteka Workbox do zarządzania Service Workerami i strategiami cache'owania (np. Stale-While-Revalidate dla zasobów statycznych, Cache-First dla modeli AI).113. Zaawansowana Analiza Obrazu i Algorytmika KolorówFundamentem aplikacji jest zdolność do poprawnego rozpoznania koloru wskazanego przez dziecko. Proste podejście oparte na wartościach RGB (Red, Green, Blue) jest skazane na porażkę w niekontrolowanych warunkach oświetleniowych, co potwierdzają liczne analizy techniczne.43.1 Ograniczenia Modelu RGBPrzestrzeń RGB została stworzona do emitowania światła (przez piksele ekranu), a nie do jego percepcji. W modelu RGB kolory są silnie skorelowane z jasnością.Przykład: Czysta czerwień to (255, 0, 0). Ta sama czerwień w cieniu może być odczytana przez kamerę jako (100, 0, 0). Dla algorytmu euklidesowego te dwa punkty są bardzo odległe, co sugeruje, że są to różne kolory.Problem Zmieszania: Żółty w RGB to (255, 255, 0). Zmniejszenie jasności wpływa na oba kanały. Weryfikacja, czy dany piksel jest „żółty”, wymagałaby skomplikowanych warunków logicznych (np. R > 200 i G > 200 i B < 50), które są kruche i podatne na błędy przy zmianie balansu bieli kamery.43.2 Implementacja Modelu HSL (Hue, Saturation, Lightness)Dla potrzeb „Łowców Kolorów” absolutnie konieczne jest przekonwertowanie strumienia wideo do przestrzeni HSL lub HSV. Jest to model cylindryczny, który oddziela informację o kolorze (Hue) od jego intensywności (Saturation) i jasności (Lightness/Value).5Hue (Barwa): Wartość kątowa na kole barw (0-360°). Czerwień jest zawsze w okolicy 0° (lub 360°), niezależnie od tego, czy przedmiot jest w słońcu, czy pod stołem.Saturation (Nasycenie): Pozwala odfiltrować kolory wyblakłe lub szare (np. biała ściana w cieniu może mieć lekki odcień niebieskiego, ale niskie nasycenie pozwoli ją odrzucić).Lightness (Jasność): Pozwala odfiltrować czerń (brak światła) i biel (prześwietlenie).Algorytm Detekcji (Core Logic):Zamiast analizować każdy piksel (co dławi procesor), stosujemy strategię próbkowania centralnego (Center Sampling).15Pobranie klatki: context.drawImage(video,...) rysuje aktualny obraz z kamery na niewidocznym elemencie <canvas>.Ekstrakcja ROI (Region of Interest): Pobieramy dane pikseli tylko ze środkowego kwadratu (np. 50x50 pikseli), gdzie znajduje się celownik widoczny dla dziecka.Średnia Przestrzenna: Obliczamy średni kolor RGB dla tego obszaru, aby zniwelować szum cyfrowy kamery (pojedyncze błędne piksele).Konwersja: Przekształcamy uśredniony RGB na HSL.Walidacja: Sprawdzamy, czy H (Hue) mieści się w zadanym zakresie, a S i L przekraczają minimalne progi (np. S > 30%, 20% < L < 80%), aby uniknąć detekcji szarości i cieni jako kolorów.Zdefiniowane Zakresy Barw dla HSL:Na podstawie analizy spektrum 17, należy przyjąć następujące zakresy dla algorytmu (uwzględniając zawijanie się koła barw przy czerwieni):KolorZakres Hue (Stopnie)UwagiCzerwony345° – 15°Wymaga obsługi logicznej OR (zakres >345 LUB <15)Pomarańczowy15° – 45°Często mylony z czerwonym przy słabym świetle; wymaga wyższego progu jasności.Żółty45° – 70°Bardzo wąski zakres percepcyjny.Zielony75° – 150°Szeroki zakres; kamery są najbardziej czułe na zieleń (matryca Bayer).Niebieski190° – 250°Obejmuje błękit i granat.Fioletowy260° – 315°Najtrudniejszy do detekcji w sztucznym świetle (często mylony z czarnym).Zastosowanie tych zakresów w połączeniu z logiką HSL gwarantuje, że aplikacja zadziała „bezbłędnie” w 90% domowych scenariuszy oświetleniowych.4. Wyzwania Platformy iOS: Walka z WebKitNajwiększym ryzykiem dla projektu jest ekosystem Apple. Przeglądarka Safari (i silnik WebKit, z którego korzystają wszystkie przeglądarki na iOS) posiada specyficzne ograniczenia, które, jeśli nie zostaną obsłużone, sprawią, że aplikacja będzie nieużywalna.34.1 Problem „Czarnego Ekranu” (Black Screen Bug)Jest to krytyczny błąd występujący w PWA na iOS. Gdy użytkownik zminimalizuje aplikację (np. wyjdzie do ekranu głównego) i wróci do niej po chwili, strumień wideo z getUserMedia często zamarza lub staje się czarny. Wynika to z agresywnego zarządzania energią przez iOS, który „zabija” dostęp do kamery dla procesów w tle, ale nie wznawia go poprawnie po powrocie.Rozwiązanie Techniczne:Konieczna jest implementacja nasłuchu zdarzenia visibilitychange. Aplikacja musi wykryć moment powrotu do aktywności i zrestartować strumień kamery.JavaScript// Pseudokod logiki naprawczej dla iOS
document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "visible") {
        const videoElement = document.querySelector("video");
        // Sprawdź, czy strumień jest aktywny
        if (!videoElement.srcObject ||!videoElement.srcObject.active) {
            console.log("Restarting camera stream for iOS...");
            await startCamera(); // Funkcja ponownie wywołująca getUserMedia
        }
        // Wymuś odświeżenie elementu wideo (hack dla WebKit)
        videoElement.play(); 
    }
});
Bez tego mechanizmu aplikacja będzie wymagała „twardego restartu” przez użytkownika po każdym zminimalizowaniu, co jest dyskwalifikujące w ocenie „bezbłędnego działania”.194.2 Atrybut playsinlineNa iPhone'ach domyślnym zachowaniem elementu <video> jest odtwarzanie w trybie pełnoekranowym systemowego odtwarzacza, co zasłania interfejs aplikacji (przyciski, punkty). Aby wideo z kamery było tłem (background), niezbędne jest dodanie atrybutu playsinline (oraz webkit-playsinline dla starszych wersji) w kodzie HTML.21HTML<video autoplay muted playsinline webkit-playsinline id="camera-feed"></video>
4.3 Obsługa „Notcha” i Safe AreaW trybie poziomym (landscape), który jest naturalny dla tabletów, wcięcie na kamerę (notch) lub zaokrąglone rogi ekranu mogą zasłaniać elementy interfejsu (np. licznik punktów). Aplikacja PWA musi „wiedzieć” o tych strefach.Implementacja CSS:Należy użyć zmiennych środowiskowych env() w połączeniu z meta-tagiem viewport-fit=cover.Meta Tag:HTML<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
CSS:CSS.interfejs-uzytkownika {
    padding-top: env(safe-area-inset-top);
    padding-right: env(safe-area-inset-right);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: env(safe-area-inset-left);
}
To rozwiązanie gwarantuje, że przyciski nigdy nie znajdą się pod „notchem” ani paskiem domowym (home indicator), co jest wymogiem certyfikacji UX Apple, a w przypadku PWA decyduje o profesjonalnym wyglądzie.234.4 Trwałość Uprawnień (Permissions Persistence)W przeciwieństwie do Androida, Safari na iOS często nie zapamiętuje zgody na dostęp do kamery dla aplikacji PWA dodanych do ekranu głównego. Użytkownik może być pytany o zgodę przy każdym uruchomieniu. Jest to ograniczenie systemowe (tzw. privacy feature).Strategia UX: Należy przygotować rodzica/dziecko na ten komunikat. Zamiast pozwolić, by systemowy alert zaskoczył użytkownika, aplikacja powinna najpierw wyświetlić przyjazny ekran: „Potrzebuję Twoich oczu, by szukać kolorów! Naciśnij Pozwól”. To buduje zaufanie i zmniejsza wskaźnik odrzuceń.265. Interfejs Głosowy i Lokalizacja (Język Polski)Aplikacja ma „mówić” do dziecka („Widzę kolor czerwony!”). Wykorzystanie Web Speech API (interfejs SpeechSynthesis) jest standardem, ale wsparcie dla języka polskiego wymaga precyzyjnej konfiguracji.5.1 Dostępność Polskich GłosówAndroid: Zazwyczaj posiada preinstalowane, wysokiej jakości głosy polskie (Google TTS).iOS: Oferuje głosy systemowe (np. „Zosia”, „Maja”), ale nie zawsze są one dostępne dla przeglądarki od razu po uruchomieniu strony.5.2 Problem Asynchroniczności getVoicesKluczowym problemem technicznym jest to, że metoda window.speechSynthesis.getVoices(), która zwraca listę dostępnych głosów, działa asynchronicznie. Bezpośrednie wywołanie jej przy starcie aplikacji często zwraca pustą tablicę ``, co sprawiłoby, że aplikacja byłaby niema.28Algorytm Ładowania Głosu:Aplikacja musi nasłuchiwać zdarzenia onvoiceschanged. Jeśli głosy nie załadują się w ciągu 500ms, należy zastosować mechanizm odpytywania (polling) jako fallback.JavaScript// Strategia wyboru głosu polskiego z fallbackiem
let polishVoice = null;

function setVoice() {
    const voices = window.speechSynthesis.getVoices();
    // Preferuj głosy 'lokalne' (działające offline) dla niskiej latencji
    polishVoice = voices.find(v => v.lang === 'pl-PL' && v.localService) 
|
| voices.find(v => v.lang === 'pl-PL');
}

if (speechSynthesis.onvoiceschanged!== undefined) {
    speechSynthesis.onvoiceschanged = setVoice;
}
5.3 Fallback AudioPonieważ Web Speech API może zawieść (np. stary tablet, brak polskiego pakietu językowego), aplikacja dla zapewnienia „bezbłędności” musi posiadać zestaw pre-renderowanych plików MP3 z podstawowymi komendami („Brawo”, „Szukaj czerwonego”, „To nie ten kolor”). System powinien automatycznie przełączyć się na pliki audio, jeśli polishVoice pozostanie null.306. Psychologia UX dla Dzieci (4-6 lat)Projektując interfejs dla przedszkolaków, musimy zrezygnować z paradygmatów znanych z aplikacji dla dorosłych. Dzieci w tym wieku często nie potrafią czytać, mają ograniczoną motorykę małą i krótki czas skupienia uwagi (ok. 8-10 minut).316.1 Zasady Projektowe „Zero UI”Brak Menu Tekstowego: Start aplikacji powinien od razu prowadzić do „gry”. Wybór poziomu trudności powinien odbywać się poprzez duże ikony (np. kolorowe kleksy), a nie listę.Duże Pola Dotykowe (Fat Finger Design): Elementy interfejsu, takie jak przycisk „ZROBIONE” lub „POWTÓRZ”, muszą mieć minimalny rozmiar 48x48 pikseli (zalecane 64px+), z dużym marginesem błędu, aby dziecko mogło w nie trafić nieprecyzyjnym ruchem palca.Natychmiastowa Gratyfikacja (Instant Gratification): Dziecko nie może czekać na wynik analizy. Feedback musi być natychmiastowy. Jeśli kolor jest poprawny:Wizualnie: Ekran rozbłyska konfetti (biblioteka canvas-confetti jest idealna, gdyż jest lekka i nie obciąża DOM).Dźwiękowo: Fanfary i głos lektora.Haptycznie: Wibracja telefonu (dla urządzeń wspierających Navigator.vibrate()).6.2 Chunking (Dzielenie Zadań)Zamiast polecenia „Posprzątaj pokój”, które jest abstrakcyjne i przytłaczające (szczególnie dla dzieci z ADHD), aplikacja wydaje mikro-polecenia: „Znajdź niebieski klocek”. Jest to technika behawioralna redukująca lęk przed zadaniem. Po znalezieniu przedmiotu i nagrodzie, system losuje kolejne mikro-zadanie, tworząc tzw. Dopamine Loop (pętlę dopaminową), która utrzymuje zaangażowanie dziecka.17. Strategia Instalacji i DystrybucjiPWA nie instaluje się samo. Proces ten różni się diametralnie na Androidzie i iOS, co musi zostać obsłużone w kodzie aplikacji.7.1 Android (WebAPK)Na Androidzie przeglądarka (Chrome) automatycznie wykrywa plik manifest.json i po spełnieniu kryteriów (HTTPS, odpowiednie ikony) wyświetla u dołu ekranu zachętę „Dodaj do ekranu głównego”. Aplikacja może przechwycić zdarzenie beforeinstallprompt i wyświetlić własny, duży i kolorowy przycisk instalacji wewnątrz interfejsu, co jest zalecane dla aplikacji dziecięcych.337.2 iOS (Add to Home Screen)iOS nie wspiera programowego wywoływania instalacji ani zdarzenia beforeinstallprompt. Jest to największa bariera UX.Rozwiązanie: Aplikacja musi wykryć, że działa na iOS w przeglądarce (nie w trybie standalone), i wyświetlić specjalnie przygotowaną animację/dymek wskazujący na przycisk „Udostępnij” (Share) w interfejsie Safari, z instrukcją „Dodaj do ekranu początkowego”. Wykrywanie to realizuje się poprzez analizę navigator.userAgent oraz właściwości navigator.standalone (lub window.matchMedia('(display-mode: standalone)')).358. Wnioski i Rekomendacja WdrożeniowaProjekt „Łowcy Kolorów” jako aplikacja PWA jest całkowicie wykonalny i posiada potencjał, by działać płynnie na nowoczesnych smartfonach i tabletach. Technologia WebAssembly i zoptymalizowany Canvas API pozwalają na analizę obrazu w czasie rzeczywistym bez udziału serwera, co rozwiązuje kluczowe problemy prywatności i wydajności.Główne ryzyka i wymagane działania mitygujące:Ryzyko: Problemy z kamerą na iOS (czarny ekran po wznowieniu).Mitygacja: Implementacja „twardego restartu” strumienia wideo przy zdarzeniu visibilitychange.Ryzyko: Błędna detekcja kolorów w słabym świetle.Mitygacja: Bezwzględne użycie modelu HSL zamiast RGB oraz algorytmów uśredniających (Center Sampling).Ryzyko: Brak polskiego głosu TTS.Mitygacja: Hybrydowy system audio (TTS + pliki MP3) zapewniający 100% niezawodności komunikatów.Rekomenduje się rozpoczęcie prac od prototypu (MVP) skupionego wyłącznie na mechanice kamery i detekcji HSL na urządzeniu iOS, gdyż jest to „wąskie gardło” technologiczne. Po potwierdzeniu stabilności na platformie Apple, portowanie na Androida będzie procesem trywialnym.9. Szczegółowa Specyfikacja Techniczna i Kod (Appendix)9.1 Konfiguracja Manifestu (manifest.json)Poniższa konfiguracja zapewnia poprawne wyświetlanie jako samodzielna aplikacja, ukrywając pasek adresu i nawigacji przeglądarki.JSON{
  "name": "Łowcy Kolorów",
  "short_name": "Łowcy",
  "start_url": "/index.html",
  "display": "standalone",
  "background_color": "#FFD700",
  "theme_color": "#FFD700",
  "orientation": "any", 
  "icons": [
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
Uwaga: Ustawienie orientation: "any" jest zalecane dla tabletów, ale dla telefonów można wymusić portrait, jeśli interfejs nie jest w pełni responsywny.9.2 Implementacja Service Workera (Caching)Zastosowanie strategii CacheFirst dla zasobów krytycznych (modele, dźwięki, obrazy) zapewnia natychmiastowe uruchamianie aplikacji.JavaScript// sw.js - Service Worker z użyciem Workbox
import { registerRoute } from 'workbox-routing';
import { CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

// Cache dla plików statycznych (JS, CSS, HTML)
registerRoute(
  ({request}) => request.destination === 'script' |

| request.destination === 'style' |
| request.destination === 'document',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
  })
);

// Cache dla ciężkich zasobów (Modele AI, Dźwięki MP3)
registerRoute(
  ({request}) => request.destination === 'image' |

| request.destination === 'audio',
  new CacheFirst({
    cacheName: 'media-assets',
    plugins:,
  })
);
9.3 Algorytm Detekcji Koloru (HSL)Poniższy kod JavaScript demonstruje optymalną metodę konwersji i detekcji, uwzględniającą cykliczność barwy czerwonej.JavaScript/**
 * Konwertuje RGB na HSL
 * @param {number} r - Czerwony (0-255)
 * @param {number} g - Zielony (0-255)
 * @param {number} b - Niebieski (0-255)
 * @returns {Array}
 */
function rgbToHsl(r, g, b) {
    r /= 255; g /= 255; b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // achromatyczny (szary)
    } else {
        const d = max - min;
        s = l > 0.5? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return [h * 360, s * 100, l * 100];
}

/**
 * Sprawdza, czy kolor pasuje do celu
 * @param {number} h - Hue
 * @param {number} s - Saturation
 * @param {number} l - Lightness
 * @param {string} targetColor - Np. 'red', 'blue'
 */
function isColorMatch(h, s, l, targetColor) {
    // Odrzucamy kolory o niskim nasyceniu (szarości) i skrajnej jasności (czerń/biel)
    if (s < 20 |

| l < 15 |
| l > 85) return false;

    switch (targetColor) {
        case 'red':
            // Czerwień jest na początku i końcu koła barw (345-360 i 0-15)
            return (h >= 345 |

| h <= 15);
        case 'blue':
            return (h >= 190 && h <= 250);
        case 'green':
            return (h >= 75 && h <= 150);
        case 'yellow':
            return (h >= 45 && h <= 70);
        // Dodatkowe kolory...
        default:
            return false;
    }
}
Dzięki takiemu podejściu, aplikacja zyskuje solidne podstawy techniczne, by stać się hitem edukacyjnym, łączącym zabawę z nauką w sposób dostępny, bezpieczny i nowoczesny.